\input texinfo.tex
@setfilename mime-en.info
@settitle{FLIM 1.8 Manual about MIME Features}
@titlepage
@title FLIM 1.8 Manual about MIME Features
@author MORIOKA Tomohiko <morioka@@jaist.ac.jp>
@subtitle 1998/07/01
@end titlepage
@node Top, Introduction, (dir), (dir)
@top FLIM 1.8 Manual about MIME Features

@ifinfo

This file documents MIME features of FLIM, a Internet message
parsing/encoding library for GNU Emacs.
@end ifinfo

@menu
* Introduction::                What is FLIM?
* How to use::                  How to use MIME features
* Entity::                      Message and Entity
* Content-Type::                Information of Content-Type field
* Content-Disposition::         Content-Disposition 欄の情報
* Content-Transfer-Encoding::   符号化法
* encoded-word::                Header の network 表現
* custom::                      一般設定
* Appendix::                    
* Concept Index::               
* Function Index::              
* Variable Index::              
@end menu

@node Introduction, How to use, Top, Top
@chapter What is FLIM?

FLIM is a library to provide basic features about message
representation or encoding.


@node How to use, Entity, Introduction, Top
@chapter How to use MIME features

Please eval following to use MIME features provided by FLIM:

@lisp
(require 'mime)
@end lisp



@node Entity, Content-Type, How to use, Top
@chapter Message and Entity
@cindex node-id
@cindex entity-number
@cindex mime-entity
@cindex entity

According to RFC 2045 (@ref{RFC 2045}), `The term ``entity'', refers
specifically to the MIME-defined header fields and contents of either a
message or one of the parts in the body of a multipart entity.'  In this
document, the term @strong{entity} indicates all of header fields and
body.@refill

The definition of RFC 2045 indicates that a MIME message is a tree.  An
message is a tree, each node is an entity, like following figure.
Namely MIME extends message to tree structure.@refill

FLIM uses @strong{mime-entity} structure to represent information of
entity.  In this document, it is called simply `mime-entity'.@refill

前述のように、message 中の各 entity は木の節に当たりますが、この木には
深さと同じ深さの中の順番に従って番号が付けることができます。即ち、
@example

                              ┌───┐
                              │  nil │
                              └─┬─┘
              ┌─────────┼─────────┐
            ┌┴┐              ┌┴┐              ┌┴┐
            │０│              │１│              │２│
            └┬┘              └┬┘              └┬┘
              │        ┌────┼────┐        │
          ┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐
          │ ０.０││ １.０││ １.１││ １.２││ ２.０│
          └───┘└───┘└───┘└───┘└───┘
@end example

@noindent
のように深さ n の節には長さ n の整数列の節番号が振れます。これ
を @strong{entity-number} と呼びます。entity-number は S 式と
しては @code{(1 2 3)} のような整数のリストとして表現されます。

mime-entity では、これと同様の @strong{node-id} を用います。node-id はちょ
うど entity-number を逆にしたリストで、entity-number 1.2.3 に対応する 
node-id は @code{(3 2 1)} です。@refill

前述のように、MIME message は entity を単位とした木構造になっているので、
この根である message 全体も mime-entity で表現することができ、buffer
local 変数 @code{mime-message-structure} に格納することにします。
そして、entity-number や node-id を用いることで 
@code{mime-message-structure} における entity の相対的な位置関係を
扱うことができます。


@menu
* Entity creation::             Functions to create mime-entity
* Entity hierarchy::            Features about message tree
* Entity Attributes::           Functions about attributes of mime-entity
* Entity-header::               Information of entity header
* Entity-content::              Contents of Entity
* Entity buffer::               Entity as buffer representation
* mm-backend::                  Entity representations and implementations
@end menu

@node Entity creation, Entity hierarchy, Entity, Entity
@section Functions to create mime-entity

@defun mime-open-entity &optional  type location

Open an entity and return it.@refill

@var{type} is representation-type. (cf. @ref{mm-backend}) @refill

@var{location} is location of entity.  Specification of it is depended
on representation-type.
@end defun


@defun mime-parse-message &optional  default-ctl node-id

Parse current buffer as message, and return the result as mime-entity.
@end defun


@defun mime-parse-buffer &optional  buffer

Parse @var{buffer} as message, and set the result to buffer local
variable @code{mime-message-structure} of @var{buffer} as
mime-entity.@refill

If @var{buffer} is omitted, current buffer is used.
@end defun



@node Entity hierarchy, Entity Attributes, Entity creation, Entity
@section Features about message tree

@defvar mime-message-structure

Buffer local variable to store mime-entity structure of message.
@end defvar


@defun mime-entity-children entity

Return list of entities included in the @var{entity}.
@end defun


@defun mime-entity-parent entity  &optional  message

Return parent entity of the @var{entity}.@refill

If @var{message} is specified, it is regarded as root instead of
@code{mime-message-structure}.
@end defun


@defun mime-root-entity-p entity

Return non-@code{nil} if @var{entity} is root entity (message).
@end defun


@defun mime-entity-node-id entity

Return node-id of @var{entity}.
@end defun


@defun mime-entity-number entity

Return entity-number of @var{entity}.
@end defun


@defun mime-find-entity-from-number entity-number  &optional  message

Return entity from @var{entity-number} in @var{message}.@refill

If @var{message} is not specified, @code{mime-message-structure} is
used.
@end defun


@defun mime-find-entity-from-node-id entity-node-id  &optional  message

Return entity from @var{entity-node-id} in @var{message}.@refill

If @var{message} is not specified, @code{mime-message-structure} is
used.
@end defun



@node Entity Attributes, Entity-header, Entity hierarchy, Entity
@section Functions about attributes of mime-entity

@defun mime-entity-content-type entity

Return content-type of @var{entity}.  (cf. @ref{mime-content-type})
@end defun


@defun mime-entity-content-disposition entity

Return content-disposition of
@var{entity}. (cf. @ref{mime-content-disposition})
@end defun


@defun mime-entity-filename entity

Return file name of @var{entity}.
@end defun


@defun mime-entity-encoding entity

Return content-transfer-encoding of @var{entity}.
(cf. @ref{Content-Transfer-Encoding})
@end defun


@defun mime-entity-cooked-p entity

Return non-nil if contents of @var{entity} has been already
code-converted.
@end defun



@node Entity-header, Entity-content, Entity Attributes, Entity
@section Information of entity header

@defun mime-fetch-field field-name  &optional  entity

Return field-body of @var{field-name} field in header of
@var{entity}.@refill

The results is network representation.@refill

If @var{entity} is omitted, @code{mime-message-structure} is used as
default value.@refill

If @var{field-name} field is not found, this function returns
@code{nil}.
@end defun


@defun mime-read-field field-name  &optional  entity

Parse @var{field-name} field in header of @var{entity}, and return the
result.@refill

Format of result is depended on kind of field.  For non-structured
field, this function returns string.  For structured field, it returns
list corresponding with structure of the field.@refill

Strings in the result will be converted to internal representation of
Emacs.@refill

If @var{entity} is omitted, @code{mime-message-structure} is used as
default value.@refill

If @var{field-name} field is not found, this function returns
@code{nil}.
@end defun


@defun mime-insert-decoded-header entity  &optional  invisible-fields visible-fields

Insert before point a decoded contents of header of @var{entity}.@refill

@var{invisible-fields} is list of regexps to match field-name to hide.
@var{visible-fields} is list of regexps to match field-name to
hide.@refill

If a field-name is matched with some elements of @var{invisible-fields}
and matched with none of @var{visible-fields}, this function don't
insert the field.
@end defun



@node Entity-content, Entity buffer, Entity-header, Entity
@section Contents of Entity

@defun mime-entity-content entity

Return content of @var{entity} as byte sequence.
@end defun


@defun mime-write-entity-content entity filename

Write content of @var{entity} into @var{filename}.
@end defun


@defun mime-write-entity entity filename

Write representation of @var{entity} into @var{filename}.
@end defun


@defun mime-write-entity-body entity filename

Write body of @var{entity} into @var{filename}.
@end defun



@node Entity buffer, mm-backend, Entity-content, Entity
@section Entity as buffer representation

@defun mime-entity-buffer entity

Return buffer, which contains @var{entity}.
@end defun


@defun mime-entity-point-min entity

Return the start point of @var{entity} in the buffer which contains
@var{entity}.
@end defun


@defun mime-entity-point-max entity

Return the end point of @var{entity} in the buffer which contains
@var{entity}.
@end defun


@defun mime-entity-header-start entity

Return the start point of header of @var{entity} in the buffer which
contains @var{entity}.
@end defun


@defun mime-entity-header-end entity

Return the end point of header of @var{entity} in the buffer which
contains @var{entity}.
@end defun


@defun mime-entity-body-start entity

Return the start point of body of @var{entity} in the buffer which
contains @var{entity}.
@end defun


@defun mime-entity-body-end entity

Return the end point of body of @var{entity} in the buffer which
contains @var{entity}.
@end defun



@node mm-backend,  , Entity buffer, Entity
@section Entity representations and implementations
@cindex mm-backend
@cindex entity 処理 method
@cindex representation-type

Entity は抽象化されたデータ表現で、実際のデータ表現としては用途に応じて
さまざまなものが利用できるように設計されています。@refill

ここで、entity がどういう種類の表現を行っているかを示すのが
@strong{representation-type} で、entity を生成する時にはこれを指定します。
(cf. @ref{Entity Creation}) @refill

前節までに述べて来た entity に対する処理は、entity に対してその処理を依
頼することによって実現されています。Entity は自分の representation-type 
を知っており、その representation-type に応じて実際の処理を行う関数を呼
び出します。このような関数を @strong{entity 処理method} と呼びます。また、
representation-type 毎にこのような関数をまとめたものを 
@strong{mm-backend} と呼びます。@refill

mm-backend は representation-type の名前の先頭に @code{mm} という
接頭辞を付けた関数名からなる module で、その module 名は同様に
representation-type の名前の先頭に @code{mm} を付けたものになって
います。この module は representation-type の entity が最初に生成される
時に自動的に require されます。


@menu
* Request for entity::          Message-passing for entity
* mm-backend module::           How to make mm-backend
@end menu

@node Request for entity, mm-backend module, mm-backend, mm-backend
@subsection Message-passing for entity

@defun mime-entity-send entity message  &rest  args

@var{entity} に @var{message} を送る。@refill

@var{args} は @var{message} の引数である。
@end defun



@node mm-backend module,  , Request for entity, mm-backend
@subsection How to make mm-backend

（すみません。そのうち書きます (^_^;）@refill

（とりあえず、mm*.el を参考にしてください）


@node Content-Type, Content-Disposition, Entity, Top
@chapter Information of Content-Type field
@cindex mime-content-type
@cindex Content-Type field

@strong{Content-Type field} is a field to indicate kind of contents or
data format, such as media-type (@ref{media-type}) and MIME charset.  It
is defined in RFC 2045 (@ref{RFC 2045}).

@noindent
@strong{[Memo]}
@quotation

Historically, Content-Type field was proposed in RFC 1049.  In it,
Content-Type did not distinguish type and subtype, and there are no
mechanism to represent kind of character code like MIME charset.
@end quotation


FLIM は Content-Type 欄を構文解析する関数と Content-Type 欄の解析結果を
格納する構造体 @strong{mime-content-type} を提供します。


@menu
* Content-Type field::          Format of Content-Type field
* mime-content-type::           mime-content-type structure
* Content-Type parser::         Content-Type 欄の解析器
* Content-Type utility::        Content-Type に関する有用な関数
@end menu

@node Content-Type field, mime-content-type, Content-Type, Content-Type
@section Format of Content-Type field
@cindex parameter
@cindex subtype
@cindex type

Content-Type 欄の形式は以下のように定義されています：

@quotation
``Content-Type'' ``:'' @strong{type} ``/''
@strong{subtype} *( ``;'' @strong{parameter} )
@end quotation

例えば、

@quotation
@example
Content-Type: image/jpeg
@end example
@end quotation

@noindent
や

@quotation
@example
Content-Type: text/plain; charset=iso-2022-jp
@end example
@end quotation

@noindent
などのように用いられます。

ここで、`type' と `subtype' は entity の形式を示すもので、両者を総称し
て、`media-type' と呼ぶことにします。上記の例における `image/jpeg' や
`text/plain' は media-type の１つです。

@noindent
@strong{[Memo]}
@quotation

Content-Type 欄のない entity は

@quotation
@example
Content-Type: text/plain; charset=us-ascii
@end example
@end quotation

@noindent
として解釈される。(cf. @ref{us-ascii})
@end quotation



@node mime-content-type, Content-Type parser, Content-Type field, Content-Type
@section mime-content-type structure

@deffn{Structure} mime-content-type

Content-Type 欄の情報を格納するための構造体。@refill

この構造体を参照するには @code{mime-content-type-要素名} という名前の参
照関数を用いる。@refill

この構造体の要素は以下の通りである：

@table @var
@item primary-type
media-type の主型 (symbol).

@item subtype
media-type の副型 (symbol).

@item parameters
Content-Type 欄の parameter (連想 list).

@end table
@end deffn


@defun make-mime-content-type type subtype
	   &optional  parameters

content-type の生成子。
@end defun


@defun mime-content-type-parameter content-type parameter

@var{content-type} の @var{parameter} の値を返す。
@end defun



@node Content-Type parser, Content-Type utility, mime-content-type, Content-Type
@section Content-Type 欄の解析器

@defun mime-parse-Content-Type string

@var{string} を content-type として解析した結果を返す。
@end defun


@defun mime-read-Content-Type

現在の buffer の Content-Type 欄を読み取り、解析した結果を返す。@refill

Content-Type 欄が存在しない場合は nil を返す。
@end defun



@node Content-Type utility,  , Content-Type parser, Content-Type
@section Content-Type に関する有用な関数

@defun mime-type/subtype-string type  &optional  subtype

@var{type} と @var{subtype} から type/subtype 形式の文字列を返す。
@end defun



@node Content-Disposition, Content-Transfer-Encoding, Content-Type, Top
@chapter Content-Disposition 欄の情報
@cindex mime-content-disposition
@cindex RFC 2183
@cindex Standards Track
@cindex Content-Disposition 欄

@strong{Content-Disposition 欄} は entity の表示や file 名など
の属性になどに関する情報を記述するためのものです。


@noindent
[RFC 2183]
@quotation
S. Dorner, K. Moore and R. Troost, ``Communicating Presentation
Information in Internet Messages: The Content-Disposition Header'',
August 1997, Standards Track.
@end quotation

FLIM は Content-Disposition 欄を構文解析する関数と Content-Disposition 
欄の解析結果を格納する構造体 
@strong{mime-content-disposition} を提供します。


@menu
* mime-content-disposition::    mime-content-disposition 構造体
* Content-Disposition parser::  Content-Disposition 欄の解析器
@end menu

@node mime-content-disposition, Content-Disposition parser, Content-Disposition, Content-Disposition
@section mime-content-disposition 構造体

@deffn{Structure} mime-content-disposition

Content-Disposition 欄の解析結果を収めるための構造体。@refill

この構造体を参照するには @code{mime-content-disposition-要素名} という名
前の参照関数を用いる。@refill

この構造体の要素は以下の通りである：

@table @var
@item disposition-type
disposition-type (symbol).

@item parameters
Content-Disposition 欄の parameter (連想 list).

@end table
@end deffn


@defun mime-content-disposition-parameter content-disposition parameter

@var{content-disposition} の @var{parameter} の値を返す。
@end defun


@defun mime-content-disposition-filename content-disposition

@var{content-disposition} の filename の値を返す。
@end defun



@node Content-Disposition parser,  , mime-content-disposition, Content-Disposition
@section Content-Disposition 欄の解析器

@defun mime-parse-Content-Disposition string

@var{string} を content-disposition として解析した結果を返す。
@end defun


@defun mime-read-Content-Disposition

現在の buffer の Content-Disposition 欄を読み取り、解析した結果を返す。
@refill

Content-Disposition 欄が存在しない場合は nil を返す。
@end defun



@node Content-Transfer-Encoding, encoded-word, Content-Disposition, Top
@chapter 符号化法
@cindex Content-Transfer-Encoding 欄

@strong{Content-Transfer-Encoding 欄} は entity の符号化法を記述するため
のものです。@refill

FLIM では Content-Transfer-Encoding 欄を構文解析する関数を提供します。こ
れらの関数は Content-Transfer-Encoding 欄の情報は文字列で表現します。
@refill

また、Content-Transfer-Encoding に基づいて符号化・復号化を行う関数も提
供されます。


@menu
* Content-Transfer-Encoding parser::  Content-Transfer-Encoding 欄の解析器
* Region encoder/decoder::      領域の符号化・復号化
* String encoder/decoder::      文字列の符号化・復号化
* File encoder/decoder::        File の符号化・復号化
@end menu

@node Content-Transfer-Encoding parser, Region encoder/decoder, Content-Transfer-Encoding, Content-Transfer-Encoding
@section Content-Transfer-Encoding 欄の解析器

@defun mime-parse-Content-Transfer-Encoding string

@var{string} を content-transfer-encoding として解析した結果を返す。
@end defun


@defun mime-read-Content-Transfer-Encoding &optional default-encoding

現在の buffer の Content-Transfer-Encoding 欄を読み取り、解析した結果を
返す。@refill

Content-Transfer-Encoding 欄が存在しない場合は@var{default-encoding} を
返す。
@end defun



@node Region encoder/decoder, String encoder/decoder, Content-Transfer-Encoding parser, Content-Transfer-Encoding
@section 領域の符号化・復号化

@defun mime-encode-region start end encoding

Encode region @var{start} to @var{end} of current buffer using
@var{encoding}.
@end defun


@defun mime-decode-region start end encoding

Decode region @var{start} to @var{end} of current buffer using
@var{encoding}.
@end defun


@defvar mime-encoding-method-alist

Alist of encoding vs. corresponding method to encode region.@refill

Each element looks like @code{(STRING . FUNCTION)} or @code{(STRING
. nil)}.  @var{string} is content-transfer-encoding.  @code{function} is
region encoder and @code{nil} means not to encode.
@end defvar


@defvar mime-decoding-method-alist

Alist of encoding vs. corresponding method to decode region.@refill

Each element looks like @code{(STRING . FUNCTION)} or @code{(STRING
. nil)}.  @var{string} is content-transfer-encoding.  @code{function} is
region decoder and @code{nil} means not to decode.
@end defvar



@node String encoder/decoder, File encoder/decoder, Region encoder/decoder, Content-Transfer-Encoding
@section 文字列の符号化・復号化

@defun mime-decode-string string encoding

@var{string} を @var{encoding} として復号した結果を返します。
@end defun


@defvar mime-string-decoding-method-alist

Alist of encoding vs. corresponding method to decode string.@refill

Each element looks like @code{(STRING . FUNCTION)}.  STRING is
content-transfer-encoding.  FUNCTION is string decoder.
@end defvar



@node File encoder/decoder,  , String encoder/decoder, Content-Transfer-Encoding
@section File の符号化・復号化

@defun mime-insert-encoded-file filename encoding

Insert file @var{FILENAME} encoded by @var{ENCODING} format.
@end defun


@defun mime-write-decoded-region start end filename encoding

Decode and write current region encoded by @var{encoding} into
@var{filename}.@refill

@var{start} and @var{end} are buffer positions.
@end defun


@defvar mime-file-encoding-method-alist

Alist of encoding vs. corresponding method to insert encoded
file.@refill

Each element looks like @code{(STRING . FUNCTION)}.  STRING is
content-transfer-encoding.  FUNCTION is function to insert encoded file.
@end defvar


@defvar mime-file-decoding-method-alist

Alist of encoding vs. corresponding method to write decoded region to
file.@refill

Each element looks like @code{(STRING . FUNCTION)}.  STRING is
content-transfer-encoding.  FUNCTION is function to write decoded region
to file.
@end defvar



@node encoded-word, custom, Content-Transfer-Encoding, Top
@chapter Header の network 表現
@cindex RFC 2047
@cindex Standards Track
@cindex RFC 2047

encoded-word は header で非 ASCII (@ref{ASCII}) 文字を表現するための形式
で、@strong{RFC 2047} で定義されています。@refill


@noindent
[RFC 2047]
@quotation
K. Moore, ``MIME (Multipurpose Internet Mail Extensions) Part Three:
Message Header Extensions for Non-ASCII Text'', November 1996, Standards
Track (obsolete RFC 1521,1522,1590).
@end quotation

また、行儀の悪いことだと言えますが、encoded-word を用いずに非 ASCII
(@ref{ASCII}) 文字を header に入れた記事も存在します。@refill

FLIM はこれらを符号化・復号化する機能を提供します。


@menu
* Header encoder/decoder::      Header の符号化・復号化
@end menu

@node Header encoder/decoder,  , encoded-word, encoded-word
@section Header の符号化・復号化

@defun eword-encode-header &optional  code-conversion separator

Decode MIME encoded-words in header fields.@refill

If @var{code-conversion} is @code{nil}, it decodes only encoded-words.
If it is mime-charset, it decodes non-ASCII bit patterns as the
mime-charset.  Otherwise it decodes non-ASCII bit patterns as the
default-mime-charset.@refill

If @var{separator} is not nil, it is used as header separator.
@end defun


@defun eword-encode-header &optional  code-conversion

Encode header fields to network representation, such as MIME
encoded-word.@refill

It refer variable @code{eword-field-encoding-method-alist}.
@end defun



@node custom, Appendix, encoded-word, Top
@chapter 一般設定

@deffn{group} mime

MIME 関連機能に関する group.@refill

@code{mail} と @code{news} に属する。
@end deffn


@defvar default-mime-charset

適切な MIME charset (@ref{MIME charset}) が見つからなかった場合に用いら
れるMIME charset.@refill

本来は APEL の変数である。
@end defvar


@defvar mime-temp-directory

MIME 機能に関する実装が一時的に使用する file を作成する 
directory.@refill

環境変数 @code{MIME_TMP_DIR}, @code{TM_TMP_DIR}, @code{TMPDIR},
@code{TMP} もしくは @code{TEMP} が設定されていた場合、それを初期値として
用いる。何も設定されていない場合、@code{"/tmp/"} を用いる。
@end defvar



@node Appendix, Concept Index, custom, Top
@chapter Appendix


@menu
* Glossary::                    
* Bug report::                  How to report bugs
* CVS::                         CVS based development
* History::                     History of FLIM
@end menu

@node Glossary, Bug report, Appendix, Appendix
@section Glossary


@menu
* 7bit::                        
* 8bit::                        
* ASCII::                       
* Base64::                      
* binary::                      
* coded character set::         Coded character set, Character code
* media-type::                  
* message::                     
* MIME::                        
* MIME charset::                
* MTA::                         
* MUA::                         
* Quoted-Printable::            
* RFC 822::                     
* RFC 1036::                    
* RFC 2045::                    
* RFC 2046::                    
* RFC 2048::                    
* RFC 2049::                    
* plain text::                  
* us-ascii::                    
@end menu

@node 7bit, 8bit, Glossary, Glossary
@subsection 7bit
@cindex 7bit (textual) string
@cindex 7bit data
@cindex 7bit

@strong{7bit} means any integer between 0 .. 127.@refill

Any data represented by 7bit integers is called @strong{7bit data}.@refill

Textual string consisted of Control characters between 0 .. 31 and 127,
and space represented by 32, and graphic characters between 33 .. 236
are called @strong{7bit (textual) string}.@refill

Conventional Internet MTA (@ref{MTA}) can translate 7bit data, so it is
no need to translate by Quoted-Printable (@ref{Quoted-Printable}) or
Base64 (@ref{Base64}) for 7bit data.@refill

However if there are too long lines, it can not translate by 7bit MTA
even if it is 7bit data.  RFC 821 (@ref{RFC 821}) and RFC 2045 (@ref{RFC 2045}) require lines in 7bit data must be less than 998 bytes.  So if a
``7bit data'' has a line more than 999 bytes, it is regarded as binary
(@ref{binary}).  For example, Postscript file should be encoded by
Quoted-Printable.


@node 8bit, ASCII, 7bit, Glossary
@subsection 8bit
@cindex 8bit (textual) string
@cindex 8bit data
@cindex 8bit

@strong{8bit} means any integer between 0 .. 255.@refill

Any data represented by 8bit integers is called @strong{8bit data}.@refill

Textual string consisted of Control characters between 0 .. 31, 127, and
128 .. 159, and space represented by 32, and graphic characters between
33 .. 236 and 160 .. 255 are called @strong{8bit (textual) string}.@refill

For example, iso-8859-1 (@ref{iso-8859-1}) or euc-kr (@ref{euc-kr}) are
coded-character-set represented by 8bit textual string.@refill

Traditional Internet MTA (@ref{MTA}) can translate only 7bit
(@ref{7bit}) data, so if a 8bit data will be translated such MTA, it
must be encoded by Quoted-Printable (@ref{Quoted-Printable}) or Base64
(@ref{Base64}).@refill

However 8bit MTA are increasing today.@refill

However if there are too long lines, it can not translate by 8bit MTA
even if it is 8bit data.  RFC 2045 (@ref{RFC 2045}) require lines in
8bit data must be less than 998 bytes.  So if a ``8bit data'' has a line
more than 999 bytes, it is regarded as binary (@ref{binary}), so it must
be encoded by Base64 or Quoted-Printable.


@node ASCII, Base64, 8bit, Glossary
@subsection ASCII
@cindex ANSI X3.4:1986
@cindex ASCII
@cindex ASCII

@strong{ASCII} is a 94-character set contains primary latin characters
(A-Z, a-z), numbers and some characters.  It is a standard of the United
States of America.  It is a variant of ISO 646 (@ref{ISO 646}).


@noindent
[ASCII]
@quotation
``Coded Character Set -- 7-Bit American Standard Code for Information
Interchange'', ANSI X3.4:1986.
@end quotation



@node Base64, binary, ASCII, Glossary
@subsection Base64
@cindex pad
@cindex Base64

@strong{Base64} is a transfer encoding method of MIME (@ref{MIME})
defined in RFC 2045 (@ref{RFC 2045}).@refill

The encoding process represents 24-bit groups of input bits as output
strings of 4 encoded characters.  Encoded characters represent integer 0
.. 63 or @strong{pad}.  Base64 data must be 4 * n bytes, so pad is used
to adjust size.@refill

These 65 characters are subset of all versions of ISO 646, including
US-ASCII, and all versions of EBCDIC.  So it is safe even if it is
translated by non-Internet gateways.


@node binary, coded character set, Base64, Glossary
@subsection binary
@cindex binary

Any byte stream is called @strong{binary}.@refill

It does not require structureof lines.  It differs from from 8bit
(@ref{8bit}).@refill

In addition, if line structured data contain too long line (more than
998 bytes), it is regarded as binary.


@node coded character set, media-type, binary, Glossary
@subsection Coded character set, Character code

A set of unambiguous rules that establishes a character set and the
one-to-one relationship between the characters of the set and their
bit combinations.


@node media-type, message, coded character set, Glossary
@subsection media-type
@cindex x-token
@cindex message
@cindex multipart
@cindex application
@cindex video
@cindex audio
@cindex image
@cindex text
@cindex subtype
@cindex type
@cindex media-type

@strong{media-type} specifies the nature of the data in the body of MIME
(@ref{MIME}) entity (@ref{entity}).  It consists of @strong{type} and
@strong{subtype}.  It is defined in RFC 2046 (@ref{RFC 2046}).@refill

Currently there are following standard primary-types:

@itemize @bullet
@item
@strong{text}
@item
@strong{image}
@item
@strong{audio}
@item
@strong{video}
@item
@strong{application}
@item
@strong{multipart} (@ref{multipart})
@item
@strong{message}
@end itemize


And there are various subtypes, for example, application/octet-stream,
audio/basic, image/jpeg, multipart/mixed (@ref{multipart/mixed}),
text/plain (@ref{text/plain}), video/mpeg...  @refill

You can refer registered media types at MEDIA TYPES
(ftp://ftp.isi.edu/in-notes/iana/assignments/media-types).@refill

In addition, you can use private type or subtype using @strong{x-token},
which as the prefix `x-'.  However you can not use them in
public.@refill

(cf. @ref{Content-Type field})



@node message, MIME, media-type, Glossary
@subsection message

In this document, it means mail defined in RFC 822 (@ref{RFC 822}) and
news message defined in RFC 1036 (@ref{RFC 1036}).


@node MIME, MIME charset, message, Glossary
@subsection MIME
@cindex Multipurpose Internet Mail Extensions

MIME stands for @strong{Multipurpose Internet Mail Extensions}, it is an
extension for RFC 822 (@ref{RFC 822}).@refill

According to RFC 2045:@refill

STD 11, RFC 822, defines a message representation protocol specifying
considerable detail about US-ASCII message headers, and leaves the
message content, or message body, as flat US-ASCII text.  This set of
documents, collectively called the Multipurpose Internet Mail
Extensions, or MIME, redefines the format of messages to allow for

@enumerate
@item
textual message bodies in character sets other than US-ASCII,
@item
an extensible set of different formats for non-textual message
bodies,
@item
multi-part message bodies, and
@item
textual header information in character sets other than US-ASCII.
@end enumerate


It is defined in RFC 2045 (@ref{RFC 2045}), RFC 2046 (@ref{RFC 2046}),
RFC 2047 (@ref{encoded-word}), RFC 2048 (@ref{RFC 2048}) and RFC 2049
(@ref{RFC 2049}).


@node MIME charset, MTA, MIME, Glossary
@subsection MIME charset

Coded character set (@ref{coded character set}) used in Content-Type
field (@ref{Content-Type field}) or charset parameter of encoded-word
(@ref{encoded-word}).@refill

It is defined in RFC 2045 (@ref{RFC 2045}).@refill

iso-2022-jp (@ref{iso-2022-jp}) or euc-kr (@ref{euc-kr}) are kinds of
it.  (In this document, MIME charsets are written by small letters to
distinguish graphic character set (@ref{graphic character set}).  For
example, ISO 8859-1 is a graphic character set, and iso-8859-1 is a MIME
charset)


@node MTA, MUA, MIME charset, Glossary
@subsection MTA
@cindex Message Transfer Agent

@strong{Message Transfer Agent}.  It means mail transfer programs
(ex. sendmail) and news servers.@refill

(cf. @ref{MUA})



@node MUA, Quoted-Printable, MTA, Glossary
@subsection MUA
@cindex Message User Agent

@strong{Message User Agent}.  It means mail readers and news
readers.@refill

(cf. @ref{MTA})



@node Quoted-Printable, RFC 822, MUA, Glossary
@subsection Quoted-Printable
@cindex Quoted-Printable

@strong{Quoted-Printable} is a transfer encoding method of MIME
(@ref{MIME}) defined in RFC 2045 (@ref{RFC 2045}).@refill

If the data being encoded are mostly US-ASCII text, the encoded form of
the data remains largely recognizable by humans.@refill

(cf. @ref{Base64})



@node RFC 822, RFC 1036, Quoted-Printable, Glossary
@subsection RFC 822
@cindex RFC 822
@cindex STD 11
@cindex Internet mail
@cindex Internet message
@cindex message header

A RFC defines format of Internet mail message, mainly @strong{message header}.

@noindent
@strong{[Memo]}
@quotation

news message is based on RFC 822, so @strong{Internet message} may be
more suitable than @strong{Internet mail} .
@end quotation



@noindent
[RFC 822]
@quotation
D. Crocker, ``Standard for the Format of ARPA Internet Text Messages'',
August 1982, STD 11.
@end quotation



@node RFC 1036, RFC 2045, RFC 822, Glossary
@subsection RFC 1036
@cindex RFC 1036
@cindex USENET

A RFC defines format of USENET message.  It is a subset of RFC 822
(@ref{RFC 822}).  It is not Internet standard, but a lot of netnews
excepting Usenet uses it.


@noindent
[USENET: RFC 1036]
@quotation
M. Horton and R. Adams, ``Standard for Interchange of USENET Messages'',
December 1987, (obsolete RFC 850).
@end quotation



@node RFC 2045, RFC 2046, RFC 1036, Glossary
@subsection RFC 2045
@cindex RFC 2045
@cindex Standards Track


@noindent
[RFC 2045]
@quotation
N. Freed and N. Borenstein, ``Multipurpose Internet Mail Extensions
(MIME) Part One: Format of Internet Message Bodies'', November 1996,
Standards Track (obsolete RFC 1521, 1522, 1590).
@end quotation



@node RFC 2046, RFC 2048, RFC 2045, Glossary
@subsection RFC 2046
@cindex RFC 2046
@cindex Standards Track


@noindent
[RFC 2046]
@quotation
N. Freed and N. Borenstein, ``Multipurpose Internet Mail Extensions
(MIME) Part Two: Media Types'', November 1996, Standards Track (obsolete
RFC 1521, 1522, 1590).
@end quotation



@node RFC 2048, RFC 2049, RFC 2046, Glossary
@subsection RFC 2048
@cindex RFC 2048
@cindex Standards Track


@noindent
[RFC 2048]
@quotation
N. Freed, J. Klensin and J. Postel, ``Multipurpose Internet Mail
Extensions (MIME) Part Four: Registration Procedures'', November 1996,
Standards Track (obsolete RFC 1521, 1522, 1590).
@end quotation



@node RFC 2049, plain text, RFC 2048, Glossary
@subsection RFC 2049
@cindex RFC 2049
@cindex Standards Track


@noindent
[RFC 2049]
@quotation
N. Freed and N. Borenstein, ``Multipurpose Internet Mail Extensions
(MIME) Part Five: Conformance Criteria and Examples'', November 1996,
Standards Track (obsolete RFC 1521, 1522, 1590).
@end quotation



@node plain text, us-ascii, RFC 2049, Glossary
@subsection plain text

A textual data represented by only coded character set (@ref{coded character set}).  It does not have information about font or
typesetting.  (cf. @ref{text/plain})



@node us-ascii,  , plain text, Glossary
@subsection us-ascii
@cindex ASCII
@cindex us-ascii

A MIME charset (@ref{MIME charset}) for primary Latin script mainly
written by English or other languages.@refill

It is a 7bit coded character set (@ref{coded character set}) based on
ISO 2022 (@ref{ISO 2022}), it contains only ASCII (@ref{ASCII}) and code
extension (@ref{code extension}) is not allowed.@refill

It is standard coded character set of Internet mail.  If MIME charset is
not specified, @strong{us-ascii} is used as default.@refill

In addition, @strong{ASCII} of RFC 822 (@ref{RFC 822}) should be
interpreted as us-ascii.


@node Bug report, CVS, Glossary, Appendix
@section How to report bugs
@cindex good bug report

If you write bug-reports and/or suggestions for improvement, please
send them to the tm Mailing List:

@itemize @bullet
@item
 Japanese <bug-tm-ja@@chamonix.jaist.ac.jp>
@item
 English <bug-tm-en@@chamonix.jaist.ac.jp>
@end itemize


Notice that, we do not welcome bug reports about too old version.  Bugs
in old version might be fixed.  So please try latest version at
first.@refill

You should write @strong{good bug report}.  If you write only ``FLIM
does not work'', we can not find such situations.  At least, you should
write name, type, variants and version of OS, emacs, APEL, FLIM, SEMI
and MUA, and setting.  In addition, if error occurs, to send backtrace
is very important. (cf. @ref{(emacs)Bugs}) @refill

Bug may not appear only your environment, but also in a lot of
environment (otherwise it might not bug).  Therefor if you send mail
to author directly, we must write a lot of mails.  So please send mail
to address for tm bugs instead of author.

Via the tm ML, you can report FLIM bugs, obtain the latest release of
FLIM, and discuss future enhancements to FLIM.  To join the tm ML,
send empty e-mail to:

@itemize @bullet
@item
 Japanese <tm-ja-help@@chamonix.jaist.ac.jp>
@item
 English  <tm-en-help@@chamonix.jaist.ac.jp>
@end itemize



@node CVS, History, Bug report, Appendix
@section CVS based development

FLIM の file は CVS を使って管理されています。このため、以下の方法で最
新の FLIM を入手することができます：

@example
(0) cvs login

    % cvs -d :pserver:anonymous@@chamonix.jaist.ac.jp:/hare/cvs/root \
	login

    CVS password: [CR] # NULL string

(1) checkout

    % cvs -d :pserver:anonymous@@chamonix.jaist.ac.jp:/hare/cvs/root \
	checkout [-r TAG] flim
@end example


CVS を用いた開発に参加したい方は

@itemize @bullet
@item
 <cvs@@chamonix.jaist.ac.jp>
@end itemize

@noindent
まで、account 名と UNIX の passwd と同じ形式の crypt 化された password
を沿えて御連絡ください。


@node History,  , CVS, Appendix
@section History of FLIM

FLIM の code の最古の部分は 榎並 嗣智 氏が書いた @file{mime.el}に起源し
ます。この小さな program は Nemacs で動作する iso-2022-jp の B-encoding 
専用の encoded-word の復号化プログラムでした。@refill

その後、守岡 知彦 は @file{mime.el} を元に@file{tiny-mime.el} というプロ
グラムを書きます。これは、Nemacs と Mule で動作する encoded-word の符号
化・復号化プログラムでした。@file{tiny-mime.el} は B-encoding だけでなく 
Q-encoding もsupport し、また、MULE で扱うことができるさまざまな MIME
charset (@ref{MIME charset}) を同時に使うことができました。この時、
Nemacs と Mule の双方を support するために用いられたテクニックは後に emu
package にまとめられます。@refill

この頃、守岡 知彦 は @file{tiny-mime.el} をさまざまな MUA で使うための設
定集も配布していましたが、それらは後に@file{tiny-mime.el} とともに１つの 
package にまとめられ、tm という名前で配布されます。@refill

守岡 知彦 はやがて、MIME message を閲覧するためのプログラムである
@file{tm-body.el} を書きます。これは、すぐに@file{tm-view.el} という名前
に変わりましたが、やがて、これが@file{tiny-mime.el} に代わって、tm の中
核となります。@refill

@file{tm-view.el} は当然、Content-Transfer-Encoding を扱う必要があります。
この目的のために、MEL が整備されはじめました。Base64 に関しては 
@file{tiny-mime.el} の code が移され、また、新たにQuoted-Printable の 
code が追加されました。これらが@file{mel-b.el} と @file{mel-q.el} になり
ました。@refill

また、後に、守岡 知彦 によって uuencode 用の @file{mel-u.el} が追加され、
その後に、小林 修平 氏によって x-gzip64 用の@file{mel-g.el} が追加されま
した。@refill

tm では後に、守岡 知彦 によって @file{tiny-mime.el} の再実装が行われ、こ
の過程で、STD 11 の parser が書かれました。これは、現在の 
@file{std11.el} に当たります。また、この過程で @file{tiny-mime.el} は復
号化を行う @file{tm-ew-d.el} と符号化を行う @file{tm-ew-e.el} に分けられ
ました。この両者が現在の @file{eword-decode.el} と 
@file{eword-encode.el} の先祖に当たります。@refill

後に、守岡 知彦 らによって tm の全面書き換え作業が行われ、この過程で、tm 
は APEL, MEL, SEMI, EMH, RMAIL-MIME, Gnus-MIME などに分けられました。こ
のうちの MEL が FLIM の直接の先祖に当たります。@refill

後に、APEL から @file{std11.el} が移され、また、@file{mailcap.el},
@file{eword-decode.el} および @file{eword-encode.el} が SEMI から移され、
package の名前が FLIMとなります。@refill

この直前から田中 哲 氏がより RFC に忠実な実装を書き始め、これは、現在、
FLIM の枝である ``FLIM-FLAM'' となっています。


@node Concept Index, Function Index, Appendix, Top
@chapter Concept Index

@printindex cp

@node Function Index, Variable Index, Concept Index, Top
@chapter Function Index

@printindex fn

@node Variable Index,  , Function Index, Top
@chapter Variable Index

@printindex vr
@bye
