<!doctype sinfo system>
<head>
<title>FLIM 1.5 MIME 機能説明書
<author>守岡 知彦 <mail>morioka@jaist.ac.jp</mail>
<date>1998/06/23

<toc>
</head>

<body>

<abstract>
<p>
This file documents MIME features of FLIM, a Internet message
parsing/encoding library for GNU Emacs.
<p>
GNU Emacs 用の Internet Message の解析や符号化に関する library である 
FLIM の MIME 機能に関して説明します。
</abstract>


<h1> FLIM って何？
<node> Introduction
<p>
FLIM は Internet Message の表現や符号化に関する基礎的な機能を提供する
ための library です。


<h1> FLIM の MIME 機能の使い方
<node> How to use
<p>
FLIM の提供する MIME 機能を使うためには

<lisp>
(require 'mime)
</lisp>
<p>
<noindent>を評価してください。


<h1> Content-Type 欄の情報
<node> Content-Type
<p>
<concept>Content-Type 欄</concept> は <dref>media-type</dref> や MIME
charset といった <dref>entity</dref> の内容の種類や表現形式などを記述
するためのもので、<dref>RFC 2045</dref> で定義されています。

<memo>
<p>
歴史的には RFC 1049 で Content-Type 欄が提案されている。但し、MIME の
media-type のような type と subtype の区別はなく、MIME charset のよう
な文字符号の種類を表現することもできない。
</memo>

<p>
FLIM は Content-Type 欄を構文解析する関数と Content-Type 欄の解析結果を
格納する構造体 <concept>mime-content-type</concept> を提供します。


<h2> Content-Type 欄の形式
<node> Content-Type field
<p>
Content-Type 欄の形式は以下のように定義されています：

<quote>
``Content-Type'' ``:'' <concept>type</concept> ``/''
<concept>subtype</concept> *( ``;'' <concept>parameter</concept> )
</quote>
<p>
例えば、

<quote>
<verb>
Content-Type: image/jpeg
</verb>
</quote>

<noindent>
や

<quote>
<verb>
Content-Type: text/plain; charset=iso-2022-jp
</verb>
</quote>

<noindent>
などのように用いられます。
<p>
ここで、`type' と `subtype' は entity の形式を示すもので、両者を総称し
て、`media-type' と呼ぶことにします。上記の例における `image/jpeg' や
`text/plain' は media-type の１つです。

<memo>
<p>
Content-Type 欄のない entity は

<quote>
<verb>
Content-Type: text/plain; charset=us-ascii
</verb>
</quote>

<noindent>
として解釈される。<cf node="us-ascii">
</memo>


<h2> mime-content-type 構造体
<node> mime-content-type
<p>
<define type="Structure" name="mime-content-type">
<p>
Content-Type 欄の情報を格納するための構造体。
<p>
この構造体を参照するには <code>mime-content-type-要素名</code> という名
前の参照関数を用いる。
<p>
この構造体の要素は以下の通りである：

<vl>
<dt>primary-type<dd>media-type の主型 (symbol).
</dd>
<dt>subtype<dd>media-type の副型 (symbol).
</dd>
<dt>parameters<dd>Content-Type 欄の parameter (連想 list).
</dd>
</vl>
</define>

<defun name="make-mime-content-type">
	  <args> type subtype
	  <opts> parameters
<p>content-type の生成子。
</defun>

<defun name="mime-content-type-parameter">
<args> content-type parameter
<p>
<var>content-type</var> の <var>parameter</var> の値を返す。
</defun>


<h2> Content-Type 欄の解析器
<node> Content-Type parser
<p>
<defun name="mime-parse-Content-Type">
	  <args> string
<p>
<var>string</var> を content-type として解析した結果を返す。
</defun>

<defun name="mime-read-Content-Type">
<p>
現在の buffer の Content-Type 欄を読み取り、解析した結果を返す。
<p>
Content-Type 欄が存在しない場合は nil を返す。
</defun>


<h2> Content-Type に関する有用な関数
<node> Content-Type utility
<p>
<defun name="mime-type/subtype-string">
	  <args> type <opts> subtype
<p>
<var>type</var> と <var>subtype</var> から type/subtype 形式の文字列を返
す。
</defun>


<h1> Content-Disposition 欄の情報
<node> Content-Disposition
<p>
<concept>Content-Disposition 欄</concept> は entity の表示や file 名など
の属性になどに関する情報を記述するためのものです。

<rfc number="2183" type="Standards Track"
	      author="S. Dorner, K. Moore and R. Troost"
	      title="Communicating Presentation Information in
	      Internet Messages: The Content-Disposition Header"
	      date="August 1997">
<p>
FLIM は Content-Disposition 欄を構文解析する関数と Content-Disposition 
欄の解析結果を格納する構造体 
<concept>mime-content-disposition</concept> を提供します。


<h2> mime-content-disposition 構造体
<node> mime-content-disposition
<p>
<define type="Structure" name="mime-content-disposition">
<p>
Content-Disposition 欄の解析結果を収めるための構造体。
<p>
この構造体を参照するには <code>mime-content-disposition-要素名</code> と
いう名前の参照関数を用いる。
<p>
この構造体の要素は以下の通りである：

<vl>
<dt>disposition-type<dd>disposition-type (symbol).
</dd>
<dt>parameters<dd>Content-Disposition 欄の parameter (連想 list).
</dd>
</vl>
</define>

<defun name="mime-content-disposition-parameter">
<args> content-disposition parameter
<p>
<var>content-disposition</var> の <var>parameter</var> の値を返す。
</defun>

<defun name="mime-content-disposition-filename">
<args> content-disposition
<p>
<var>content-disposition</var> の filename の値を返す。
</defun>


<h2> Content-Disposition 欄の解析器
<node> Content-Disposition parser
<p>
<defun name="mime-parse-Content-Disposition">
	    <args> string
<p>
<var>string</var> を content-disposition として解析した結果を返す。
</defun>

<defun name="mime-read-Content-Disposition">
<p>
現在の buffer の Content-Disposition 欄を読み取り、解析した結果を返す。
<p>
Content-Disposition 欄が存在しない場合は nil を返す。
</defun>


<h1> 符号化法
<node> Content-Transfer-Encoding
<p>
<concept>Content-Transfer-Encoding 欄</concept> は entity の符号化法を記
述するためのものです。
<p>
FLIM では Content-Transfer-Encoding 欄を構文解析する関数を提供します。こ
れらの関数は Content-Transfer-Encoding 欄の情報は文字列で表現します。
<p>
また、Content-Transfer-Encoding に基づいて符号化・復号化を行う関数も提
供されます。


<h2> Content-Transfer-Encoding 欄の解析器
<node> Content-Transfer-Encoding parser
<p>
<defun name="mime-parse-Content-Transfer-Encoding">
	  <args>string
<p>
<var>string</var> を content-transfer-encoding として解析した結果を返す。
</defun>

<defun name="mime-read-Content-Transfer-Encoding">
	  <opts>default-encoding
<p>
現在の buffer の Content-Transfer-Encoding 欄を読み取り、解析した結果を
返す。
<p>
Content-Transfer-Encoding 欄が存在しない場合は
<var>default-encoding</var> を返す。
</defun>


<h2> Content-Transfer-Encoding の符号化・復号化
<node> encoder/decoder

<h3> 領域の符号化・復号化
<node> Region encoder/decoder
<p>
<defun name="mime-encode-region">
	    <args> start end encoding
<p>
Encode region <var>start</var> to <var>end</var> of current buffer
using <var>encoding</var>.
</defun>

<defun name="mime-decode-region">
	    <args> start end encoding
<p>
Decode region <var>start</var> to <var>end</var> of current buffer
using <var>encoding</var>.
</defun>

<defvar name="mime-encoding-method-alist">
<p>
Alist of encoding vs. corresponding method to encode region.
<p>
Each element looks like <code>(STRING . FUNCTION)</code> or
<code>(STRING . nil)</code>.  <var>string</var> is
content-transfer-encoding.  <code>function</code> is region encoder
and <code>nil</code> means not to encode.
</defvar>

<defvar name="mime-decoding-method-alist">
<p>
Alist of encoding vs. corresponding method to decode region.
<p>
Each element looks like <code>(STRING . FUNCTION)</code> or
<code>(STRING . nil)</code>.  <var>string</var> is
content-transfer-encoding.  <code>function</code> is region decoder
and <code>nil</code> means not to decode.
</defvar>


<h3> 文字列の符号化・復号化
<node> String encoder/decoder
<p>
<defun name="mime-decode-string">
	      <args> string encoding
<p>
<var>string</var> を <var>encoding</var> として復号した結果を返します。
</defun>

<defvar name="mime-string-decoding-method-alist">
<p>
Alist of encoding vs. corresponding method to decode string.
<p>
Each element looks like <code>(STRING . FUNCTION)</code>.
STRING is content-transfer-encoding.
FUNCTION is string decoder.
</defvar>


<h3> File の符号化・復号化
<node> File encoder/decoder
<p>
<defun name="mime-insert-encoded-file">
	    <args> filename encoding
<p>
Insert file <var>FILENAME</var> encoded by <var>ENCODING</var> format.
</defun>

<defun name="mime-write-decoded-region">
	      <args> start end filename encoding
<p>
Decode and write current region encoded by <var>encoding</var> into
<var>filename</var>.
<p>
<var>start</var> and <var>end</var> are buffer positions.
</defun>

<defvar name="mime-file-encoding-method-alist">
<p>
Alist of encoding vs. corresponding method to insert encoded file.
<p>
Each element looks like <code>(STRING . FUNCTION)</code>.  STRING is
content-transfer-encoding.  FUNCTION is function to insert encoded
file.
</defvar>

<defvar name="mime-file-decoding-method-alist">
<p>
Alist of encoding vs. corresponding method to write decoded region to
file.
<p>
Each element looks like <code>(STRING . FUNCTION)</code>.  STRING is
content-transfer-encoding.  FUNCTION is function to write decoded
region to file.
</defvar>


<h1> encoded-word
<node> encoded-word
<p>
encoded-word は header で非 <dref>ASCII</dref> 文字を表現するための形
式で、<concept>RFC 2047</concept> で定義されています。
<p>
<rfc number="2047" type="Standards Track" author="K. Moore"
	      title="MIME (Multipurpose Internet Mail Extensions) Part
	      Three: Message Header Extensions for Non-ASCII Text"
	      date="November 1996" obsolete="1521,1522,1590">
<p>
また、行儀の悪いことだと言えますが、encoded-word を用いずに非 
<dref>ASCII</dref> 文字を header に入れた記事も存在します。
<p>
FLIM はこれらを符号化・復号化する機能を提供します。


<h2> Header の符号化・復号化
<node> Header encoder/decoder
<p>
<defun name="eword-encode-header">
	      <opts> code-conversion separator
<p>
Decode MIME encoded-words in header fields.
<p>
If <var>code-conversion</var> is <code>nil</code>, it decodes only
encoded-words.  If it is mime-charset, it decodes non-ASCII bit
patterns as the mime-charset.  Otherwise it decodes non-ASCII bit
patterns as the default-mime-charset.
<p>
If <var>separator</var> is not nil, it is used as header separator.
</defun>

<defun name="eword-encode-header">
	      <opts> code-conversion
<p>
Encode header fields to network representation, such as MIME
encoded-word.
<p>
It refer variable <code>eword-field-encoding-method-alist</code>.
</defun>



<h1> Message と Entity
<node> Entity structure
<p>
MIME message は <concept>entity</concept> を単位とする木構造です。
<concept>mime-entity</concept> 構造体は entity や message 全体の情報を格
納する構造体で、以下では単に mime-entity と呼ぶことにします。
<p>
message 中の各 entity は木の節に当たりますが、この木には深さと同じ深さの
中の順番に従って番号が付けることができます。即ち、
<verb>

                              ┌───┐
                              │  nil │
                              └─┬─┘
              ┌─────────┼─────────┐
            ┌┴┐              ┌┴┐              ┌┴┐
            │０│              │１│              │２│
            └┬┘              └┬┘              └┬┘
              │        ┌────┼────┐        │
          ┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐
          │ ０.０││ １.０││ １.１││ １.２││ ２.０│
          └───┘└───┘└───┘└───┘└───┘

</verb>
<p>
<noindent>のように深さ n の節には長さ n の整数列の節番号が振れます。これ
を <concept>entity-number</concept> と呼びます。entity-number は S 式と
しては <code>(1 2 3)</code> のような整数のリストとして表現されます。
<p>
mime-entity では、これと同様の <concept>node-id</concept> を用います。
node-id はちょうど entity-number を逆にしたリストで、entity-number
1.2.3 に対応する node-id は <code>(3 2 1)</code> です。
<p>
前述のように、MIME message は entity を単位とした木構造になっていますが、
この根である message 全体も mime-entity で表現することができ、buffer
local 変数 <code>mime-message-structure</code> に格納することにします。
そして、entity-number や node-id を用いることで 
<code>mime-message-structure</code> における entity の相対的な位置関係を
扱うことができます。


<h2> mime-entity 構造体
<node> mime-entity
<p>
<define type="Structure" name="mime-entity">
<p>
entity に関する情報を収める構造体。
<p>
この構造体を参照するには <code>mime-entity-要素名</code> という名前の参
照関数を用いる。
<p>
この構造体の要素は以下の通りである：

<vl>
<dt>buffer<dd>entity が存在する buffer (buffer)
</dd>
<dt>header-start<dd>entity の存在する buffer における header の先頭位置
(point)
</dd>
<dt>header-end<dd>entity の存在する buffer における header の末尾位置
(point)
</dd>
<dt>body-start<dd>entity の存在する buffer における body の先頭位置
(point)
</dd>
<dt>body-end<dd>entity の存在する buffer における body の末尾位置
(point)
</dd>
<dt>node-id<dd>entity の node-id (整数の list)
</dd>
<dt>content-type<dd>Content-Type 欄の情報 (mime-content-type)
</dd>
<dt>content-disposition<dd>Content-Disposition 欄の情報 
(mime-content-disposition)
</dd>
<dt>encoding<dd>entity の Content-Transfer-Encoding (文字列)
</dd>
<dt>children<dd>entity に含まれる entity の list (mime-entity の 
list)
</dd>
</vl>

<p>
また、過去との互換性のため、以下の要素名の参照関数も利用可能である。

<vl>
<dt>point-min<dd>entity の存在する buffer における entity の先頭位置
(point)
</dd>
<dt>point-max<dd>entity の存在する buffer における entity の末尾位置
(point)
</dd>
<dt>type/subtype<dd>entity の type/subtype (文字列)
</dd>
<dt>media-type<dd>entity の media-primary-type (symbol)
</dd>
<dt>media-subtype<dd>entity の media-subtype (symbol)
</dd>
<dt>parameters<dd>entity の Content-Type 欄の parameter (連想 list)
list)
</dd>
</vl>
</define>

<defun name="make-mime-entity">
	  <args> buffer header-start header-end body-start body-end
	  <opts> node-id content-type content-disposition encoding
	  children
<p>
entity の生成子。
</defun>


<h2> Message の解析器
<node> Message parser
<p>
<defvar name="mime-message-structure">
<p>
現在の buffer における message 全体の mime-entity 構造体を格納する
buffer local 変数。
</defvar>

<defun name="mime-parse-message">
	  <opts> default-ctl default-encoding node-id
<p>
現在の buffer を構文解析した結果を返す。
</defun>

<defun name="mime-parse-buffer">
	  <opts> buffer
<p>
<var>buffer</var> を構文解析し、その結果を <var>buffer</var> の
<code>mime-message-structure</code> に格納する。
<p>
<var>buffer</var> が省略された場合、現在の buffer を構文解析する。
</defun>


<h2> Entity の位置関係に関する機能
<node> Entity as node in message
<p>
<defun name="mime-entity-number">
	  <args> entity
<p>
<var>entity</var> の entity-number を返す。
</defun>

<defun name="mime-entity-parent">
	  <args> entity <opts> message-structure
<p>
<var>entity</var> の親の entity を返す。
<p>
<var>message-structure</var> が省略された場合は entity が存在する 
buffer における <code>mime-message-structure</code> の値を用いる。
<p>
<var>message-structure</var> が指定された場合、これを根と見倣す。
</defun>

<defun name="mime-root-entity-p">
	  <args> entity
<p>
<var>entity</var> が根（即ち、message 全体）である場合に、
非-<code>nil</code> を返す。
</defun>


<h2> Entity header の情報
<node> Entity-header
<p>
<defun name="mime-entity-fetch-field">
	    <args> entity field-name
<p>
<var>entity</var> の header 中の <var>field-name</var> 欄の body を返す。
<p>
結果の文字列は network 表現のままである。
<p>
<var>field-name</var> 欄が存在しない場合は nil を返す。
</defun>

<defun name="mime-entity-read-field">
	    <args> entity field-name
<p>
<var>entity</var> の header 中の <var>field-name</var> 欄を構文解析した
結果を返す。
<p>
結果の形式は欄毎に異なる。非構造化欄の場合は文字列を返し、構造化欄の場合
はその形式に従った list を返す。
<p>
結果中の文字列は Emacs の内部表現に変換される。
<p>
<var>field-name</var> 欄が存在しない場合は nil を返す。
</defun>

<defun name="mime-insert-decoded-header">
	    <args> entity <opts> invisible-fields visible-fields
	    code-conversion
<p>
現在位置に <var>entity</var> の復号した header を挿入する。
<p>
<var>invisible-fields</var> と <var>visible-fields</var> は正規表現の
list で、それぞれ、表示したくない field 名と表示したい欄名を表現したもの
である。
<p>
<var>invisible-fields</var> の要素のどれかに match し、かつ、
<var>visible-fields</var> の要素のどれにも match しない欄は表示されない。
</defun>


<h2> Entity の内容
<node> Entity-content
<p>
<defun name="mime-entity-content">
	    <args> entity
<p>
<var>entity</var> の内容の byte 列を返す。
</defun>


<h1> 付録
<node> Appendix

<h2> 用語
<node> Glossary

<h3> 7bit
<node> 7bit
<p>
ここでは 0 から 127 の整数を指す。
<p>
0 から 127 の整数の列で表現できるような data を ``7bit の data'' と呼
ぶ。
<p>
また、0 から 31 および 127 で表現される制御文字と 32 で表現される空白
と 33 から 126 で表現される図形文字からなる文字列のことを ``7bit の文
字列'' と呼ぶ（これは <dref>ISO 2022</dref> の「7 単位系」と同様）。
<p>
伝統的な Internet の <dref>MTA</dref> は 7bit の data を転送できるので、
7bit の data は <dref>Quoted-Printable</dref> や <dref>Base64</dref> 
といった変換を行わなくてもそのまま転送できる。
<p>
しかし、7bit であればどんな data でも良いとはいえない。なぜなら、１行
の長さがあまりに長いと、MTA はその message を転送することができないか
らである。ちなみに、<dref>RFC 821</dref> は１行は改行文字を除いて 998
byte 以内であることを求めている。よって、これ以上の行が含まれる可能性
のある data, 例えば、Postscript の data などは Quoted-Printable 等で 
encodeする必用がある。


<h3> 8bit
<node> 8bit
<p>
ここでは 0 から 255 の整数を指す。
<p>
0 から 255 の整数の列で表現できるような data を ``8bit の data'' と呼
ぶ。
<p>
また、0 から 31, 127 および 128 から 159 で表現される制御文字と 32 で
表現される空白と 33 から 126 と 160 から 255 で表現される図形文字から
なる文字列のことを ``8bit の文字列'' と呼ぶ（これは <dref>ISO
2022</dref> の「8 単位系」と同様）。
<p>
<dref>iso-8859-1</dref> や <dref>euc-kr</dref> といった符号化文字集合
は 8bit の文字列である。
<p>
伝統的な Internet の <dref>MTA</dref> は <dref>7bit</dref> の data し
か転送できないので、そうした MTA を経由する場合、
<dref>Quoted-Printable</dref> や <dref>Base64</dref> といった変換を行
わなくてはならない。
<p>
しかし、最近では 8bit の文字列をそのまま通すことができる MTA も登場し
てきたので、そのまま送ることができる場合も増えてきた。
<p>
しかし、8bit であればどんな data でも良いとはいえない。なぜなら、１行
の長さがあまりに長いと、MTA はその message を転送することができないか
らである。ちなみに、<dref>RFC 821</dref> は１行は改行文字を除いて 998
byte 以内であることを求めている。よって、これ以上の行が含まれる可能性
のある data, 例えば、Postscript の data などは Quoted-Printable 等で 
encodeする必用がある。
<p>
また、こうした理由から、１行が 999 byte 以上の行が存在する可能性のある
data は <a node="binary"><concept>binary</concept></a> と呼ぶことにす
る。
<p>
ちなみに、7bit で表現できる data は 8bit でも表現できる。よって、
``8bit'' と言った場合、１行が 998 byte 以下の任意の data を指すことが
ある。


<h3> Base64
<node> Base64
<p>
<dref>RFC 2045</dref> で定義されている <dref>MIME</dref> における <a
node="binary">binary data</a> の network での変換法の１つ。
<p>
『64 進数』という意味で、3 byte の data を 0 から 63 の数を表す 
<dref>ASCII</dref> 4 文字に変換する方法。（もし、4 文字にならなければ 
<concept>pad</concept> と呼ばれる詰め物をして長さを調整する）
<p>
この 65 種類の文字は ASCII と EBCDIC の共通部分から選ばれており、
Internet 以外の network を経由する場合でも安全に転送できるように設計さ
れている。


<h3> ASCII
<node> ASCII
<p>
アメリカ連邦で使われる文字を符号化した<dref>符号化文字集合</dref>。
A-Z, a-z の Latin 文字と数字、幾つかの記号からなる。ISO 646 の一つで、
現在は国際基準版 (IRV) になっている。

<standard abbrev="ASCII" title-en="Coded Character Set -- 7-Bit
	      American Standard Code for Information Interchange"
	      number="ANSI X3.4" year="1986">


<h3> Coded character set（符号化文字集合）, Character code（文字符号）
<node> Coded character set
<p>
文字と byte 列と１対１に対応付ける曖昧でない規則の集合。


<h3> binary
<node> binary
<p>
任意の byte 列を <concept>binary</concept> と呼ぶ。
<p>
<dref>8bit</dref> と異なるのは data に行の構造を仮定しないことである。
<p>
また、行の構造があっても、999 byte 以上からなる行がある場合も binary 
と呼ぶことにする。
<p>
ちなみに、<dref>7bit</dref> や 8bit で表現できる data は binary でも表
現できる。よって、<concept>binary data</concept> と言った場合、任意の 
data を指すことがある。


<h3> Entity
<node> entity
<p>
ある message もしくは multipart message の１つの part の header と 
body を併せたもの。


<h3> media-type
<node> media-type
<p>
<dref>MIME</dref> における <dref>entity</dref> の種類。
<concept>primary-type</concept> と <concept>subtype</concept> からなる。
<dref>RFC 2046</dref> で定義されている。
<p>
type は標準では

<ul>
<li><concept>text</concept>
</li>
<li><concept>image</concept>
</li>
<li><concept>audio</concept>
</li>
<li><concept>video</concept>
</li>
<li><concept>application</concept>
</li>
<li><a node="multipart"><concept>multipart</concept></a>
</li>
<li><concept>message</concept>
</ul>

<noindent>
が定義され、それぞれには application/octet-stream, audio/basic,
image/jpeg, <dref>multipart/mixed</dref>, <dref>text/plain</dref>,
video/mpeg などのさまざまな subtype が定義されている。

<memo title="注意">
<p>
ここでは、text/plain などの type/subtype の組をしばしば 
<concept>primary-type/subtype</concept> と書く。
</memo>

<p>
media-type は、RFC 2046 で定義されているものに加えて、登録することもで
きる。現在、登録されているものは <a
href="ftp://ftp.isi.edu/in-notes/iana/assignments/media-types">MEDIA
TYPES</a> で参照できる。
<p>
また、type もしくは subtype に、前に `x-' を付けた 
<concept>x-token</concept> を用いることにより、登録されていないものを
私的に用いることもできる。しかし、当然のことながら、こうした私的な 
media-type は諒解を得た者の間でしか解釈できないので利用には注意するこ
と。
<p>
<cf node="Content-Type">


<h3> message
<node> message
<p>
ここでは mail と news 記事の総称として用いる。


<h3> MIME
<node> MIME
<p>
<concept>Multipurpose Internet Mail Extensions</concept> の略で、
Internet の mail や news で <a node="us-ascii">us-ascii plain text</a> 
以外の文字を使うための <dref>RFC 822</dref> に対する拡張。
<p>
RFC 2045 は冒頭で次のように述べている：
<p>
STD 11, RFC 822 は、US-ASCII message header に関して非常に詳細に規定し
た message 表現 protocol を定義している。しかし、それは単に flat な 
US-ASCII text のみに留まり、message の内容や message body に関する規定
はなされていない。Multipurpose Internet Mail Extensions, あるいは MIME 
と総称される、この一連の文書は、以下の事を可能とするために message の
形式を再定義した：

<ol>
<li>文書 message body における US-ASCII 以外の文字集合
</li>
<li>非文書 message body
</li>
<li>複数の部分からなる message body
</li>
<li>US-ASCII 以外の文字集合からなる文書 header 情報
</ol>

<p>
<dref>RFC 2045</dref>, <dref>RFC 2046</dref>, <a
node="encoded-word">RFC 2047</a>, <dref>RFC 2048</dref>, <dref>RFC
2049</dref> で定義されている。


<h3> MIME charset
<node> MIME charset
<p>
<dref>Content-Type</dref> 欄や <dref>encoded-word</dref> の charset
parameter で用いられる登録された<a node="Coded character set">符号化文
字集合</a>。
<p>
<dref>RFC 2045</dref> で定義されている。
<p>
iso-2022-jp や euc-kr はその１つ。


<h3> MTA
<node> MTA
<p>
<concept>Message Transfer Agent</concept> の略で、qmail や sendmail な
どの mail 配送 program と inn などの news server の総称。
<p>
<cf node="MUA">


<h3> MUA
<node> MUA
<p>
<concept>Message User Agent</concept> の略で、mail reader と news
reader の総称。
<p>
<cf node="MTA">


<h3> Quoted-Printable
<node> Quoted-Printable
<p>
<dref>RFC 2045</dref> で定義されている <dref>MIME</dref> における 
<dref>binary data</dref> の network での変換法の１つ。
<p>
`=' や制御文字や 128 以上の文字などは `=AF' のように `=' の後に続く 16 
進数で表現する。このため、<dref>ASCII</dref> 文字中心の data では 
<dref>Base64</dref> に比べると可読性が高くなる可能性がある。
<p>
しかしながら、EBCDIC には存在しない文字を利用する場合、EBCDIC を利用し
ている network では安全に転送することができず、Base64 に比べて安全性は
低い。


<h3> RFC 822
<node> RFC 822
<p>
Internet mail の主に <concept>message header</concept> に関する形式に
関する標準を定めている RFC.

<memo>
<p>
news message もこれに準じているので、<concept>Internet mail</concept> 
と書くよりも、<concept>Internet message</concept> と書いた方が良いかも
しれない。
</memo>

<rfc number="822" type="STD 11" author="D. Crocker" title="Standard
	      for the Format of ARPA Internet Text Messages"
	      date="August 1982">


<h3> RFC 1036
<node> RFC 1036
<p>
USENET での message の形式を定めた RFC.  <dref>RFC 822</dref> の 
subset になっている。Internet の標準ではないが、USENET 以外の netnews 
でもこれに準じているものが多い。

<rfc name="USENET" number="1036" author="M. Horton and R. Adams"
	      title="Standard for Interchange of USENET Messages"
	      date="December 1987" obsolete="850">


<h3> RFC 2045
<node> RFC 2045
<p>
<rfc number="2045" type="Standards Track" author="N. Freed and
	      N. Borenstein" title="Multipurpose Internet Mail
	      Extensions (MIME) Part One: Format of Internet Message
	      Bodies" date="November 1996" obsolete="1521, 1522,
	      1590">


<h3> RFC 2046
<node> RFC 2046
<p>
<rfc number="2046" type="Standards Track" author="N. Freed and
	      N. Borenstein" title="Multipurpose Internet Mail
                 Extensions (MIME) Part Two: Media Types"
                 date="November 1996" obsolete="1521, 1522, 1590">


<h3> RFC 2048
<node> RFC 2048
<p>
<rfc number="2048" type="Standards Track" author="N. Freed, J. Klensin
	      and J. Postel" title="Multipurpose Internet Mail
	      Extensions (MIME) Part Four: Registration Procedures"
	      date="November 1996" obsolete="1521, 1522, 1590">


<h3> RFC 2049
<node> RFC 2049
<p>
<rfc number="2049" type="Standards Track" author="N. Freed and
	      N. Borenstein" title="Multipurpose Internet Mail
	      Extensions (MIME) Part Five: Conformance Criteria and
	      Examples" date="November 1996" obsolete="1521, 1522,
	      1590">


<h3> plain text
<node> plain text
<p>
書体や組版に関する情報を持たない<a node="Coded character set">文字符号
</a>のみで表現される text 情報。<cf node="text/plain">


<h3> us-ascii
<node> us-ascii
<p>
アメリカ連邦などで使われる英語などを表現するための <dref>MIME
charset</dref> の１つ。
<p>
<dref>ASCII</dref> のみからなり ISO 2022 による符号拡張は許されない。
<p>
Internet message における標準の<a node="Coded character set">符号化文
字集合</a>であり、明示的に MIME charset が示されない場合は原則として 
<concept>us-ascii</concept> が使われる。
<p>
また、<dref>RFC 822</dref> における <concept>ASCII</concept> 
は us-ascii である。


<h2> bug 報告の仕方
<node> Bug report
<p>
FLIM のバグを見つけたら、以下の address に mail を送ってください：

<ul>
<li> 日本語 <mail>bug-tm-ja@chamonix.jaist.ac.jp</mail>
<li> 英語 <mail>bug-tm-en@chamonix.jaist.ac.jp</mail>
</ul>

<p>
但し、あまりにも古い版に関する報告は歓迎されません。古い版の bug は、
新しい版では治っているかもしれません。まず、最新版で確認してみましょう。
<p>
それから、適切な報告をしましょう。単に「うまく動かない」と言われてもど
ういう状況なのかはさっぱり判りません。最低限、OS, emacs, APEL, FLIM,
SEMI, 使っている MUA の種類および版、設定を書く必要があります。また、
error が起っている場合は backtrace を送ることも重要です。<cf
file="emacs" node="Bugs">
<p>
また、bug は大抵複数の人が遭遇するものです（そうでなければ、bug ではな
い可能性があります）。だから、作者に直接 mail を送ると作者は同じ mail
を何通も書く羽目になります。だから、必ず bug 報告は上記の address に送っ
てください。

<p>
tm ML では FLIM のバグ情報の交換や最新版の配布、FLIM の改良に関する議
論を行なっています。tm ML に参加したい方は

<ul>
<li> 日本語 <mail>tm-ja-help@chamonix.jaist.ac.jp</mail>
<li> 英語 <mail>tm-en-help@chamonix.jaist.ac.jp</mail>
</ul>

<noindent>
に空の mail を送って下さい。


<h2> CVS による開発
<node> CVS
<p>
FLIM の file は CVS を使って管理されています。このため、以下の方法で最
新の FLIM を入手することができます：

<verb>
(0) cvs login

    % cvs -d :pserver:anonymous@chamonix.jaist.ac.jp:/hare/cvs/root \
	login

    CVS password: [CR] # NULL string

(1) checkout

    % cvs -d :pserver:anonymous@chamonix.jaist.ac.jp:/hare/cvs/root \
	checkout [-r TAG] gnus
</verb>

<p>
CVS を用いた開発に参加したい方は

<ul>
<li> <mail>cvs@chamonix.jaist.ac.jp</mail>
</ul>

<noindent>
まで、account 名と UNIX の passwd と同じ形式の crypt 化された password
を沿えて御連絡ください。


<h2> 歴史
<node> History
<p>
FLIM の code の最古の部分は 榎並 嗣智 氏が書いた <file>mime.el</file>
に起源します。この小さな program は Nemacs で動作する iso-2022-jp の 
B-encoding 専用の encoded-word の復号化プログラムでした。
<p>
その後、守岡 知彦 は <file>mime.el</file> を元に
<file>tiny-mime.el</file> というプログラムを書きます。これは、Nemacs 
と Mule で動作する encoded-word の符号化・復号化プログラムでした。
<file>tiny-mime.el</file> は B-encoding だけでなく Q-encoding も
support し、また、MULE で扱うことができるさまざまな <dref>MIME
charset</dref> を同時に使うことができました。この時、Nemacs と Mule の
双方を support するために用いられたテクニックは後に emu package にまと
められます。
<p>
この頃、守岡 知彦 は <file>tiny-mime.el</file> をさまざまな MUA で使う
ための設定集も配布していましたが、それらは後に
<file>tiny-mime.el</file> とともに１つの package にまとめられ、tm とい
う名前で配布されます。
<p>
守岡 知彦 はやがて、MIME message を閲覧するためのプログラムである
<file>tm-body.el</file> を書きます。これは、すぐに
<file>tm-view.el</file> という名前に変わりましたが、やがて、これが
<file>tiny-mime.el</file> に代わって、tm の中核となります。
<p>
<file>tm-view.el</file> は当然、Content-Transfer-Encoding を扱う必要が
あります。この目的のために、MEL が整備されはじめました。Base64 に関し
ては <file>tiny-mime.el</file> の code が移され、また、新たに
Quoted-Printable の code が追加されました。これらが
<file>mel-b.el</file> と <file>mel-q.el</file> になりました。
<p>
また、後に、守岡 知彦 によって uuencode 用の <file>mel-u.el</file> が
追加され、その後に、小林 修平 氏によって x-gzip64 用の
<file>mel-g.el</file> が追加されました。
<p>
tm では後に、守岡 知彦 によって <file>tiny-mime.el</file> の再実装が行
われ、この過程で、STD 11 の parser が書かれました。これは、現在の 
<file>std11.el</file> に当たります。また、この過程で 
<file>tiny-mime.el</file> は復号化を行う <file>tm-ew-d.el</file> と符
号化を行う <file>tm-ew-e.el</file> に分けられました。この両者が現在の 
<file>eword-decode.el</file> と <file>eword-encode.el</file> の先祖に
当たります。
<p>
後に、守岡 知彦 らによって tm の全面書き換え作業が行われ、この過程で、
tm は APEL, MEL, SEMI, EMH, RMAIL-MIME, Gnus-MIME などに分けられました。
このうちの MEL が FLIM の直接の先祖に当たります。
<p>
後に、APEL から <file>std11.el</file> が移され、また、
<file>mailcap.el</file>, <file>eword-decode.el</file> および 
<file>eword-encode.el</file> が SEMI から移され、package の名前が FLIM
となります。
<p>
この直前から田中 哲 氏がより RFC に忠実な実装を書き始め、これは、現在、
FLIM の枝である ``FLIM-FLAM'' となっています。


<h1> 概念索引
<node> Concept Index

<cindex>


<h1> 関数索引
<node> Function Index

<findex>


<h1> 変数索引
<node> Variable Index

<vindex>

</body>
